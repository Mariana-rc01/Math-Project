<!DOCTYPE html>
<html>
<head>
	<title>Math project</title>
	<meta charset="utf-8" />
	<style>
		body {
			background-color: white;
			margin: 0;
			overflow: hidden;
		}
		#container {
			width: 800px;
			margin: auto;
			text-align: center;
		}
		#graphDiv {
			width: 800px;
			height: 600px;
			margin: auto;
		}
		#controls {
			margin-top: 20px;
		}
		.slider {
			width: 600px;
			margin: 10px auto;
		}
		.coordinates {
			margin-top: 10px;
		}
		.input-field {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
		}
		.input-label {
			margin-right: 10px;
		}
		.input-value {
			width: 60px;
			padding: 2px;
		}
	</style>
	<script src="https://cdn.rawgit.com/mrdoob/three.js/r129/build/three.min.js"></script>
</head>
<body>
	<div id="container">
		<div id="graphDiv"></div>
		<div id="controls">
			<div class="slider">
				<label for="x">X:</label>
				<div class="input-field">
					<input type="range" id="x" min="-1" max="1" step="0.1" value="0" />
					<input type="text" id="xValue" class="input-value" />
				</div>
			</div>
			<div class="slider">
				<label for="y">Y:</label>
				<div class="input-field">
					<input type="range" id="y" min="-1" max="1" step="0.1" value="0" />
					<input type="text" id="yValue" class="input-value" />
				</div>
			</div>
			<div class="slider">
				<label for="z">Z:</label>
				<div class="input-field">
					<input type="range" id="z" min="-1" max="1" step="0.1" value="0" />
					<input type="text" id="zValue" class="input-value" />
				</div>
			</div>
			<div class="coordinates">
				<span id="coordinates">P = (0, 0, 0)</span>
			</div>
		</div>
	</div>

	<script>
		function createReferenceAxes() {
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
			camera.position.set(0, 0, 5);
			camera.lookAt(scene.position);

			const renderer = new THREE.WebGLRenderer({ alpha: true });
			renderer.setClearColor(0xffffff, 1);
			renderer.setSize(800, 600);
			document.getElementById("graphDiv").appendChild(renderer.domElement);

			const axesHelper = new THREE.AxesHelper(2);
			axesHelper.material.depthTest = false;
			axesHelper.material.transparent = true;
			axesHelper.material.opacity = 1;
			axesHelper.material.color.set(0x000000); // Definir a cor dos eixos como preto
			scene.add(axesHelper);

			const originGeometry = new THREE.SphereGeometry(0.05);
			const originMaterial = new THREE.MeshBasicMaterial({ color: "black" });
			const origin = new THREE.Mesh(originGeometry, originMaterial);
			scene.add(origin);

			const geometry = new THREE.SphereGeometry(1, 32, 32);
			const material = new THREE.MeshBasicMaterial({ color: "lightsteelblue", wireframe: true });
			const sphere = new THREE.Mesh(geometry, material);
			scene.add(sphere);

			const lineMaterial = new THREE.LineBasicMaterial({ color: "orange" });
			const lineGeometry = new THREE.BufferGeometry().setFromPoints([
				new THREE.Vector3(0, 0, 0),
				new THREE.Vector3(0, 0, 0),
			]);
			const line = new THREE.Line(lineGeometry, lineMaterial);
			scene.add(line);

			const pointMaterial = new THREE.MeshBasicMaterial({ color: "red" });
			const pointGeometry = new THREE.SphereGeometry(0.05);
			const point = new THREE.Mesh(pointGeometry, pointMaterial);
			scene.add(point);

			const fontLoader = new THREE.FontLoader();
			fontLoader.load("https://cdn.rawgit.com/mrdoob/three.js/r129/examples/fonts/helvetiker_regular.typeface.json", function (
				font
			) {
				const textMaterial = new THREE.MeshBasicMaterial({ color: "black" });

				const zTextGeometry = new THREE.TextGeometry("z", {
					font: font,
					size: 0.2,
					height: 0.02,
				});
				const zText = new THREE.Mesh(zTextGeometry, textMaterial);
				zText.position.set(0, 0, 1.2);
				scene.add(zText);

				const yTextGeometry = new THREE.TextGeometry("y", {
					font: font,
					size: 0.2,
					height: 0.02,
				});
				const yText = new THREE.Mesh(yTextGeometry, textMaterial);
				yText.position.set(0, 1.2, 0);
				scene.add(yText);

				const xTextGeometry = new THREE.TextGeometry("x", {
					font: font,
					size: 0.2,
					height: 0.02,
				});
				const xText = new THREE.Mesh(xTextGeometry, textMaterial);
				xText.position.set(1.2, 0, 0);
				scene.add(xText);
			});

			const controls = {
				x: 0,
				y: 0,
				z: 0,
			};

			const xSlider = document.getElementById("x");
			const xValue = document.getElementById("xValue");
			xSlider.addEventListener("input", () => {
				controls.x = Number(xSlider.value);
				xValue.value = controls.x;
				updatePointPosition();
			});

			const ySlider = document.getElementById("y");
			const yValue = document.getElementById("yValue");
			ySlider.addEventListener("input", () => {
				controls.y = Number(ySlider.value);
				yValue.value = controls.y;
				updatePointPosition();
			});

			const zSlider = document.getElementById("z");
			const zValue = document.getElementById("zValue");
			zSlider.addEventListener("input", () => {
				controls.z = Number(zSlider.value);
				zValue.value = controls.z;
				updatePointPosition();
			});

			function formatFraction(value) {
				if (value === 0) {
					return "0";
				} else if (value === Math.PI) {
					return "π";
				} else if (Math.abs(value) === Math.PI / 2) {
					const sign = Math.sign(value) === -1 ? "-" : "";
					return `${sign}π/2`;
				} else if (Math.abs(value) === Math.PI / 4) {
					const sign = Math.sign(value) === -1 ? "-" : "";
					return `${sign}π/4`;
				} else {
					const piFraction = value / Math.PI;
					return `${value.toFixed(2)}π`;
				}
			}

			function updatePointPosition() {
				const ro = Math.sqrt(controls.x ** 2 + controls.y ** 2 + controls.z ** 2);
				const theta = Math.acos(controls.x / ro);
				const phi = Math.atan2(controls.z, controls.y);

				point.position.set(controls.x, controls.y, controls.z);
				sphere.scale.set(ro, ro, ro);
				line.geometry.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(controls.x, controls.y, controls.z)]);

				const roundedRo = ro.toFixed(2);
				const roundedTheta = formatFraction(theta);
				const roundedPhi = formatFraction(phi);

				document.getElementById("coordinates").innerText = `P = (${roundedRo}, ${roundedTheta}, ${roundedPhi})`;

				renderer.render(scene, camera);
			}

			updatePointPosition();

			function animate() {
				requestAnimationFrame(animate);

				renderer.render(scene, camera);
			}

			animate();
		}

		createReferenceAxes();
	</script>
</body>
</html>
